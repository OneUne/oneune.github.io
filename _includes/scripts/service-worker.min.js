const SHELL_CACHE="shell-9.1.6--{{ cache_version }}--{{ site_key }}",ASSETS_CACHE="assets--{{ cache_version }}--{{ site_key }}",CONTENT_CACHE="content--{{ site.time | date_to_xmlschema }}--{{ site_key }}",SW_CACHE_SEARCH_PARAM="sw-cache",NO_CACHE_SEARCH_PARAM="no-cache",RE_CSS_URL=/url\s*\(['"]?(([^'"\\]|\\.)*)['"]?\)/u,ICON_FONT="{{ 'assets/icomoon/style.css' | relative_url }}",KATEX_FONT="{{ 'assets/bower_components/katex/dist/katex.min.css' | relative_url }}",GOOGLE_FONTS="{{ site.google_fonts_url | default:'https://fonts.googleapis.com' }}/css?family={{ google_fonts | uri_escape }}&display=swap",SHELL_FILES=["{{ '/assets/css/hydejack-9.1.6.css' | relative_url }}","{{ '/assets/js/service-worker.js' | relative_url }}"],STATIC_FILES=["{{ file.path | relative_url }}"],PRE_CACHED_ASSETS=['{{ "/assets/icons/favicon.ico" | relative_url }}',"{% include_cached smart-url url=site.accent_image %}","{% include_cached smart-url url=site.logo %}","{% include_cached smart-url url=file %}"],CONTENT_FILES=["{{ '/'             | relative_url }}","{{ '/offline.html' | relative_url }}","{% assign url = node.url | default: node.href %}{% include_cached smart-url url=url %}"],SITE_URL=new URL("{{ '/' | relative_url }}",self.location),OFFLINE_PAGE_URL=new URL("{{ '/offline.html' | relative_url }}",self.location),dirname=(self.addEventListener("install",e=>e.waitUntil(onInstall(e))),self.addEventListener("activate",e=>e.waitUntil(onActivate(e))),self.addEventListener("fetch",e=>e.respondWith(onFetch(e))),({pathname:e})=>e.replace(/[^/]*$/,""));function matchAll(e,t){const a=new RegExp(t,"g"),s=[];for(var n;n=a.exec(e);)s.push(n);return s}const second=([,e])=>e,toAbsoluteURL=e=>new URL(e,self.location);function noCache(e){return new Request(e,{cache:"no-store"})}function noSWParam(e){const t=new URL(e);return t.searchParams.has(SW_CACHE_SEARCH_PARAM)?(t.searchParams.delete(SW_CACHE_SEARCH_PARAM),t.href):e}const warn=e=>(console.warn(e),new Response(e.message,{status:500}));async function getIconFontFiles(){var e=STATIC_FILES.filter(e=>e.startsWith('{{ "/assets/icomoon/fonts/" | relative_url }}')&&e.endsWith(".woff"));return[ICON_FONT,...e]}async function getKaTeXFontFiles(){var e=STATIC_FILES.filter(e=>e.startsWith('{{ "/assets/bower_components/katex/dist/fonts/" | relative_url }}')&&e.endsWith(".woff2"));return[KATEX_FONT,...e]}async function getMathJaxFiles(){}async function getGoogleFontsFiles(){const e=await fetch(noCache(GOOGLE_FONTS)).catch(warn);var t;return e.ok?(t=await e.text(),[GOOGLE_FONTS,...matchAll(t,RE_CSS_URL).map(second)]):[]}function addAll(a,e){return Promise.all(e.map(t=>fetch(noCache(toAbsoluteURL(t))).then(e=>a.put(t,e)).catch(warn)))}async function cacheShell(e){var t=await Promise.all([getIconFontFiles(),getGoogleFontsFiles(),getKaTeXFontFiles(),getMathJaxFiles()]),a=STATIC_FILES.filter(e=>e.startsWith('{{ "/assets/js/" | relative_url }}')&&e.endsWith(".js")&&!e.includes("LEGACY"));return addAll(e,SHELL_FILES.concat(a,...t).filter(e=>!!e))}async function cacheAssets(e){return addAll(e,PRE_CACHED_ASSETS.filter(e=>!!e))}async function cacheContent(e){return addAll(e,CONTENT_FILES.filter(e=>!!e))}async function preCache(){const e=await caches.keys();var t,a,s;return e.includes(SHELL_CACHE)&&e.includes(ASSETS_CACHE)?cacheContent(await caches.open(CONTENT_CACHE)):([t,a,s]=await Promise.all([caches.open(SHELL_CACHE),caches.open(ASSETS_CACHE),caches.open(CONTENT_CACHE)]),Promise.all([cacheShell(t),cacheAssets(a),cacheContent(s)]))}async function onInstall(){return await preCache(),self.skipWaiting()}const isSameSite=({origin:e,pathname:t})=>e===SITE_URL.origin&&t.startsWith(SITE_URL.pathname),isAsset=({pathname:e})=>e.startsWith("{{ 'assets' | relative_url }}"),hasSWParam=({searchParams:e})=>e.has(SW_CACHE_SEARCH_PARAM),hasNoCacheParam=({searchParams:e})=>e.has(NO_CACHE_SEARCH_PARAM),isGoogleFonts=({hostname:e})=>"fonts.googleapis.com"===e||"fonts.gstatic.com"===e;async function cacheResponse(e,t,a){const s=await caches.open(e);return s.put(t,a)}async function onActivate(){await self.clients.claim();const e=await caches.keys();return Promise.all(e.filter(e=>e.endsWith("sw{{ '/' | relative_url }}")).filter(e=>e!==SHELL_CACHE&&e!==ASSETS_CACHE&&e!==CONTENT_CACHE).map(e=>caches.delete(e)))}const NEVER=new Promise(()=>{});async function raceTruthy(e){const t=[...e].map(e=>Promise.resolve(e));let a=t["length"];const s=e=>null!=e?e:0<--a?NEVER:void 0;return Promise.race(t.map(e=>e.then(s)))}async function fromNetwork(e,...t){return fetchAndCache(isAsset(e)||hasSWParam(e)?ASSETS_CACHE:CONTENT_CACHE,e,...t)}async function fetchAndCache(e,t,a,s){const n=await fetch(noCache(noSWParam(t)));return n.ok&&s.waitUntil(cacheResponse(e,a,n.clone())),n}async function onFetch(e){var t=e["request"];const a=new URL(t.url);var s=isSameSite(a)||hasSWParam(a)||isGoogleFonts(a);if("GET"!==t.method||!s||hasNoCacheParam(a))return fetch(t).catch(e=>Promise.reject(e));try{var n=await raceTruthy([caches.open(SHELL_CACHE).then(e=>e.match(a.href,{ignoreSearch:!0})),caches.open(ASSETS_CACHE).then(e=>e.match(a.href,{ignoreSearch:!0})),caches.open(CONTENT_CACHE).then(e=>e.match(a.href,{ignoreSearch:!0}))]);return n?n:await fromNetwork(a,t,e)}catch(e){const c=await caches.open(CONTENT_CACHE);return c.match(OFFLINE_PAGE_URL)}}async function onDeactivate(){await self.clients.claim();const e=await caches.keys();return Promise.all(e.filter(e=>e.endsWith("{{ site_key }}")).map(e=>caches.delete(e)))}self.addEventListener("activate",e=>e.waitUntil(onDeactivate(e)));
